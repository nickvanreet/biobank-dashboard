})
output$map_zones <- renderLeaflet({
data <- zones_map_data()
validate(need(!is.null(data), "Geen kaartgegevens beschikbaar. Upload een kaart of gebruik GRID3."))
gj <- data$gj
metric <- data$metric
pal <- data$pal
metric_title <- c(n = "Aantal stalen", pct_f = "% vrouw", med_age = "Mediaan leeftijd")[input$map_metric_zs]
metric_title <- ifelse(is.na(metric_title), "", metric_title)
border_cols <- if (isTRUE(input$outline_by_prov)) prov_outline_color(gj$prov_key) else "#444444"
leaflet(gj) |>
addProviderTiles(providers$CartoDB.Positron) |>
addPolygons(
weight = 1.2, color = border_cols, opacity = 1,
fillOpacity = 0.85, fillColor = ~pal(metric),
label = ~lapply(
sprintf(
"<b>Zone:</b> %s<br/><b>Provincie:</b> %s<br/><b>N:</b> %s<br/><b>% vrouw:</b> %s<br/><b>Mediaan leeftijd:</b> %s",
ifelse(is.na(gj[[input$zones_name_col]]), "?", gj[[input$zones_name_col]]),
ifelse(is.na(gj[[input$prov_name_col]]),  "?", gj[[input$prov_name_col]]),
ifelse(is.na(n), 0, n),
ifelse(is.na(pct_f), "-", paste0(pct_f, "%")),
ifelse(is.na(med_age), "-", round(med_age, 1))
),
htmltools::HTML
),
highlightOptions = highlightOptions(weight = 2, color = "#000000", bringToFront = TRUE)
) |>
addLegend(pal = pal, values = metric, title = metric_title, opacity = 0.9)
})
observeEvent(input$focus_kasai, {
data <- zones_map_data()
req(!is.null(data))
gj <- data$gj
if (!inherits(gj, "sf")) return()
focus <- gj |> dplyr::filter(prov_key %in% c("kasai oriental", "lomami"))
req(nrow(focus) > 0)
bbox <- sf::st_bbox(focus)
leafletProxy("map_zones") |>
fitBounds(lng1 = bbox['xmin'], lat1 = bbox['ymin'], lng2 = bbox['xmax'], lat2 = bbox['ymax'])
})
output$cols_raw <- renderPrint({
df0 <- raw_data(); if (is.null(df0)) return("[geen raw data]")
names(df0)
})
output$cols_map <- renderPrint({
dfm <- mapped_data(); if (is.null(dfm)) return("[geen mapped data]")
names(dfm)
})
output$range_dates <- renderPrint({
df <- biobank(); if (is.null(df)) return("[geen data]")
range(df$date_prelev, na.rm = TRUE)
})
output$uniques <- renderPrint({
df <- biobank(); if (is.null(df)) return("[geen data]")
list(
study    = sort(unique(na.omit(df$study)))[1:20],
province = sort(unique(na.omit(df$province)))[1:20],
zone     = sort(unique(na.omit(df$zone)))[1:20]
)
})
output$dl_csv <- downloadHandler(
filename = function(){ glue("biobank_filtered_{format(Sys.Date(), '%Y%m%d')}.csv") },
content  = function(file){ readr::write_csv(filtered(), file) }
)
output$dl_plot <- downloadHandler(
filename = function(){ glue("age_sex_pyramids_{format(Sys.Date(), '%Y%m%d')}.png") },
content  = function(file){
p <- plot_zone_pyramids(filtered(), bin = input$bin, min_n_per_zone = input$minN, split_study = input$split_study)
ggsave(file, p, width = 14, height = 9, dpi = 300)
}
)
output$dl_plot_pdf <- downloadHandler(
filename = function(){ glue("age_sex_pyramids_{format(Sys.Date(), '%Y%m%d')}.pdf") },
content  = function(file){
p <- plot_zone_pyramids(filtered(), bin = input$bin, min_n_per_zone = input$minN, split_study = input$split_study)
ggsave(file, p, width = 14, height = 9, device = grDevices::cairo_pdf) # PDF export using Cairo for crisp text
}
)
}
shinyApp(ui, server)
# app.R - Mbuji-Mayi Biobank Dashboard v3.1
# ============================================================================
# Load global configuration and libraries
source("global.R")
setwd("~/GitHub/biobank-dashboard")
# app.R - Mbuji-Mayi Biobank Dashboard v3.1
# ============================================================================
# Load global configuration and libraries
source("global.R")
# ============================================================================
# USER INTERFACE
# ============================================================================
ui <- do.call(
page_navbar,
c(
list(
title = config$app$title,
theme = app_theme,
# Sidebar with data loading and filters
sidebar = mod_data_manager_ui("data_manager")
),
# Navigation panels
list(
mod_data_quality_ui("data_quality"),
#mod_overview_assays_ui("overview_assays"),
mod_overview_demographics_ui("overview_demographics"),
mod_geographic_ui("geographic"),
mod_transport_ui("transport"),
mod_drs_ui("drs"),
mod_mic_qpcr_coordinator_ui("mic"),
mod_ielisa_coordinator_ui("ielisa"),
mod_elisa_pe_ui("elisa_pe"),
mod_elisa_vsg_ui("elisa_vsg"),
mod_elisa_concordance_ui("concordance"),
# New comprehensive analysis modules
mod_sample_journey_ui("sample_journey"),
mod_sample_processing_ui("sample_processing"),
mod_overview_assays_ui("overview_assays"),
mod_study_comparison_ui("study_comparison"),  # Study Results Comparison (DA vs DP)
mod_predictive_analytics_ui("predictive_analytics")  # Predictive Analytics (renamed from Concordance)
)
)
)
# ============================================================================
# SERVER LOGIC
# ============================================================================
server <- function(input, output, session) {
# Core data management module - returns reactive data
data <- mod_data_manager_server("data_manager")
# Pass data to data quality module
mod_data_quality_server(
"data_quality",
raw_data = data$raw_data,
clean_data = data$clean_data,
quality_report = data$quality_report
)
mod_overview_assays_server(
"overview_assays",
biobank_df = data$filtered_data,
elisa_df = data$elisa_data,
ielisa_df = data$ielisa_data,
mic_df = data$mic_data,
filters = data$filters
)
# Pass data to overview & demographics module
mod_overview_demographics_server(
"overview_demographics",
filtered_data = data$filtered_data
)
# MIC qPCR module - FIXED to use new coordinator architecture
mic_data <- mod_mic_qpcr_coordinator_server(
"mic",
biobank_df = data$clean_data,              # ← Biobank data from data manager
extractions_df = data$filtered_extractions, # ← Extractions data from data manager
filters = data$filters                      # ← Filters from data manager (FIXED)
)
# Unified DRS module (extraction quality + RNAseP + QC warnings)
# Now initialized after MIC module so qPCR data is available
mod_drs_server(
"drs",
extractions_df = data$filtered_extractions,
qpcr_data = mic_data$qpcr_samples,
biobank_df = data$filtered_data,
filters = data$filters
)
# iELISA module - Inhibition ELISA for LiTat 1.3 and 1.5
ielisa_data <- mod_ielisa_coordinator_server(
"ielisa",
biobank_df = data$clean_data,
filters = data$filters
)
# ELISA modules - using new coordinator architecture (capture return values for downstream modules)
elisa_pe_data <- mod_elisa_pe_server(
"elisa_pe",
biobank_df = data$clean_data,
filters = data$filters
)
elisa_vsg_data <- mod_elisa_vsg_server(
"elisa_vsg",
biobank_df = data$clean_data,
filters = data$filters
)
# Wrap MIC data for transport module (expects $samples structure)
mic_data_for_transport <- reactive({
tryCatch({
if (is.null(mic_data) || is.null(mic_data$qpcr_samples)) return(NULL)
samples <- mic_data$qpcr_samples()
if (is.null(samples) || !nrow(samples)) return(NULL)
list(samples = samples)
}, error = function(e) {
message("Warning: Could not get MIC data for transport: ", e$message)
NULL
})
})
# Wrap iELISA data for transport module (expects dataframe, not list)
ielisa_data_for_transport <- reactive({
tryCatch({
if (is.null(ielisa_data) || is.null(ielisa_data$samples)) return(NULL)
samples <- ielisa_data$samples()
if (is.null(samples) || !nrow(samples)) return(NULL)
samples
}, error = function(e) {
message("Warning: Could not get iELISA data for transport: ", e$message)
NULL
})
})
# Combine ELISA data (PE + VSG) for transport module
combined_elisa_data <- reactive({
pe_data <- elisa_pe_data$samples()
vsg_data <- elisa_vsg_data$samples()
if (is.null(pe_data)) pe_data <- tibble::tibble()
if (is.null(vsg_data)) vsg_data <- tibble::tibble()
if (nrow(pe_data) == 0 && nrow(vsg_data) == 0) return(NULL)
# Add test_type column to distinguish PE from VSG in transport module
if (nrow(pe_data) > 0) {
pe_data <- pe_data %>% dplyr::mutate(test_type = "PE")
}
if (nrow(vsg_data) > 0) {
vsg_data <- vsg_data %>% dplyr::mutate(test_type = "VSG")
}
dplyr::bind_rows(pe_data, vsg_data)
})
# Pass filtered data to transport module so visuals respect dashboard filters
mod_transport_server(
"transport",
filtered_data = data$filtered_data,
mic_data = mic_data_for_transport,
elisa_data = combined_elisa_data,
ielisa_data = ielisa_data_for_transport
)
# Geographic visualization module (map with test results)
mod_geographic_server(
"geographic",
filtered_data = data$filtered_data,
mic_data = mic_data$qpcr_samples,
elisa_pe_data = elisa_pe_data$samples,
elisa_vsg_data = elisa_vsg_data$samples,
ielisa_data = ielisa_data$samples
)
# ELISA Concordance module (PE vs VSG comparison)
mod_elisa_concordance_server(
"concordance",
biobank_df = data$clean_data,
filters = data$filters
)
# Update DRS module with qPCR data (now that MIC module is initialized)
# Note: The DRS module will receive qPCR data through the reactive data flow
# Sample Journey module (comprehensive sample tracking)
mod_sample_journey_server(
"sample_journey",
biobank_data = data$clean_data,
extraction_data = data$filtered_extractions,
mic_data = mic_data$qpcr_samples,
elisa_pe_data = elisa_pe_data$samples,
elisa_vsg_data = elisa_vsg_data$samples,
ielisa_data = ielisa_data$samples
)
# Sample Processing module (comprehensive sample processing overview)
mod_sample_processing_server(
"sample_processing",
biobank_df = data$filtered_data,  # Use filtered_data to respect global filters
extraction_df = data$filtered_extractions,
mic_df = mic_data$qpcr_samples,
elisa_pe_df = elisa_pe_data$samples,
elisa_vsg_df = elisa_vsg_data$samples,
ielisa_df = ielisa_data$samples,
filters = data$filters
)
# Study Results Comparison module (DA vs DP comparison across all metrics)
mod_study_comparison_server(
"study_comparison",
biobank_df = data$filtered_data,
extraction_df = data$filtered_extractions,
mic_df = mic_data$qpcr_samples,
elisa_pe_df = elisa_pe_data$samples,
elisa_vsg_df = elisa_vsg_data$samples,
ielisa_df = ielisa_data$samples,
filters = data$filters
)
# Predictive Analytics module (epidemiological forecasting and risk prediction)
mod_predictive_analytics_server(
"predictive_analytics",
biobank_df = data$clean_data,
mic_df = mic_data$qpcr_samples,
elisa_pe_df = elisa_pe_data$samples,
elisa_vsg_df = elisa_vsg_data$samples,
ielisa_df = ielisa_data$samples,
filters = data$filters
)
# Session management
session$onSessionEnded(function() {
message("Session ended")
})
}
# ============================================================================
# RUN APPLICATION
# ============================================================================
shinyApp(ui, server)
# app.R - Mbuji-Mayi Biobank Dashboard v3.1
# ============================================================================
# Load global configuration and libraries
source("global.R")
# ============================================================================
# USER INTERFACE
# ============================================================================
ui <- do.call(
page_navbar,
c(
list(
title = config$app$title,
theme = app_theme,
# Sidebar with data loading and filters
sidebar = mod_data_manager_ui("data_manager")
),
# Navigation panels
list(
mod_data_quality_ui("data_quality"),
#mod_overview_assays_ui("overview_assays"),
mod_overview_demographics_ui("overview_demographics"),
mod_geographic_ui("geographic"),
mod_transport_ui("transport"),
mod_drs_ui("drs"),
mod_mic_qpcr_coordinator_ui("mic"),
mod_ielisa_coordinator_ui("ielisa"),
mod_elisa_pe_ui("elisa_pe"),
mod_elisa_vsg_ui("elisa_vsg"),
mod_elisa_concordance_ui("concordance"),
# New comprehensive analysis modules
mod_sample_journey_ui("sample_journey"),
mod_sample_processing_ui("sample_processing"),
mod_overview_assays_ui("overview_assays"),
mod_study_comparison_ui("study_comparison"),  # Study Results Comparison (DA vs DP)
mod_predictive_analytics_ui("predictive_analytics")  # Predictive Analytics (renamed from Concordance)
)
)
)
# ============================================================================
# SERVER LOGIC
# ============================================================================
server <- function(input, output, session) {
# Core data management module - returns reactive data
data <- mod_data_manager_server("data_manager")
# Pass data to data quality module
mod_data_quality_server(
"data_quality",
raw_data = data$raw_data,
clean_data = data$clean_data,
quality_report = data$quality_report
)
mod_overview_assays_server(
"overview_assays",
biobank_df = data$filtered_data,
elisa_df = data$elisa_data,
ielisa_df = data$ielisa_data,
mic_df = data$mic_data,
filters = data$filters
)
# Pass data to overview & demographics module
mod_overview_demographics_server(
"overview_demographics",
filtered_data = data$filtered_data
)
# MIC qPCR module - FIXED to use new coordinator architecture
mic_data <- mod_mic_qpcr_coordinator_server(
"mic",
biobank_df = data$clean_data,              # ← Biobank data from data manager
extractions_df = data$filtered_extractions, # ← Extractions data from data manager
filters = data$filters                      # ← Filters from data manager (FIXED)
)
# Unified DRS module (extraction quality + RNAseP + QC warnings)
# Now initialized after MIC module so qPCR data is available
mod_drs_server(
"drs",
extractions_df = data$filtered_extractions,
qpcr_data = mic_data$qpcr_samples,
biobank_df = data$filtered_data,
filters = data$filters
)
# iELISA module - Inhibition ELISA for LiTat 1.3 and 1.5
ielisa_data <- mod_ielisa_coordinator_server(
"ielisa",
biobank_df = data$clean_data,
filters = data$filters
)
# ELISA modules - using new coordinator architecture (capture return values for downstream modules)
elisa_pe_data <- mod_elisa_pe_server(
"elisa_pe",
biobank_df = data$clean_data,
filters = data$filters
)
elisa_vsg_data <- mod_elisa_vsg_server(
"elisa_vsg",
biobank_df = data$clean_data,
filters = data$filters
)
# Wrap MIC data for transport module (expects $samples structure)
mic_data_for_transport <- reactive({
tryCatch({
if (is.null(mic_data) || is.null(mic_data$qpcr_samples)) return(NULL)
samples <- mic_data$qpcr_samples()
if (is.null(samples) || !nrow(samples)) return(NULL)
list(samples = samples)
}, error = function(e) {
message("Warning: Could not get MIC data for transport: ", e$message)
NULL
})
})
# Wrap iELISA data for transport module (expects dataframe, not list)
ielisa_data_for_transport <- reactive({
tryCatch({
if (is.null(ielisa_data) || is.null(ielisa_data$samples)) return(NULL)
samples <- ielisa_data$samples()
if (is.null(samples) || !nrow(samples)) return(NULL)
samples
}, error = function(e) {
message("Warning: Could not get iELISA data for transport: ", e$message)
NULL
})
})
# Combine ELISA data (PE + VSG) for transport module
combined_elisa_data <- reactive({
pe_data <- elisa_pe_data$samples()
vsg_data <- elisa_vsg_data$samples()
if (is.null(pe_data)) pe_data <- tibble::tibble()
if (is.null(vsg_data)) vsg_data <- tibble::tibble()
if (nrow(pe_data) == 0 && nrow(vsg_data) == 0) return(NULL)
# Add test_type column to distinguish PE from VSG in transport module
if (nrow(pe_data) > 0) {
pe_data <- pe_data %>% dplyr::mutate(test_type = "PE")
}
if (nrow(vsg_data) > 0) {
vsg_data <- vsg_data %>% dplyr::mutate(test_type = "VSG")
}
dplyr::bind_rows(pe_data, vsg_data)
})
# Pass filtered data to transport module so visuals respect dashboard filters
mod_transport_server(
"transport",
filtered_data = data$filtered_data,
mic_data = mic_data_for_transport,
elisa_data = combined_elisa_data,
ielisa_data = ielisa_data_for_transport
)
# Geographic visualization module (map with test results)
mod_geographic_server(
"geographic",
filtered_data = data$filtered_data,
mic_data = mic_data$qpcr_samples,
elisa_pe_data = elisa_pe_data$samples,
elisa_vsg_data = elisa_vsg_data$samples,
ielisa_data = ielisa_data$samples
)
# ELISA Concordance module (PE vs VSG comparison)
mod_elisa_concordance_server(
"concordance",
biobank_df = data$clean_data,
filters = data$filters
)
# Update DRS module with qPCR data (now that MIC module is initialized)
# Note: The DRS module will receive qPCR data through the reactive data flow
# Sample Journey module (comprehensive sample tracking)
mod_sample_journey_server(
"sample_journey",
biobank_data = data$clean_data,
extraction_data = data$filtered_extractions,
mic_data = mic_data$qpcr_samples,
elisa_pe_data = elisa_pe_data$samples,
elisa_vsg_data = elisa_vsg_data$samples,
ielisa_data = ielisa_data$samples
)
# Sample Processing module (comprehensive sample processing overview)
mod_sample_processing_server(
"sample_processing",
biobank_df = data$filtered_data,  # Use filtered_data to respect global filters
extraction_df = data$filtered_extractions,
mic_df = mic_data$qpcr_samples,
elisa_pe_df = elisa_pe_data$samples,
elisa_vsg_df = elisa_vsg_data$samples,
ielisa_df = ielisa_data$samples,
filters = data$filters
)
# Study Results Comparison module (DA vs DP comparison across all metrics)
mod_study_comparison_server(
"study_comparison",
biobank_df = data$filtered_data,
extraction_df = data$filtered_extractions,
mic_df = mic_data$qpcr_samples,
elisa_pe_df = elisa_pe_data$samples,
elisa_vsg_df = elisa_vsg_data$samples,
ielisa_df = ielisa_data$samples,
filters = data$filters
)
# Predictive Analytics module (epidemiological forecasting and risk prediction)
mod_predictive_analytics_server(
"predictive_analytics",
biobank_df = data$clean_data,
mic_df = mic_data$qpcr_samples,
elisa_pe_df = elisa_pe_data$samples,
elisa_vsg_df = elisa_vsg_data$samples,
ielisa_df = ielisa_data$samples,
filters = data$filters
)
# Session management
session$onSessionEnded(function() {
message("Session ended")
})
}
# ============================================================================
# RUN APPLICATION
# ============================================================================
shinyApp(ui, server)
