# ==============================================================================
# MODULE 4: ANALYSIS - MIC qPCR Analysis Dashboard
# Redesigned for CRT DIPUMBA - Clear, Insightful, Beautiful
# ==============================================================================
#
# NOTE: This module uses FinalCall values (Positive, Positive_DNA, Positive_RNA,
# LatePositive, Negative, etc.) which are generated by the MIC qPCR pipeline.
# For standardized classification functions shared across all modules, see:
# R/utils_standardized_counting.R (is_mic_positive, classify_mic_finalcall, etc.)
# ==============================================================================

mod_mic_analysis_ui <- function(id) {
  ns <- NS(id)

  tagList(
    tags$style(HTML(
      "
      .mic-plot-card .card-body {
        overflow: visible;
      }

      .mic-plot-card .plotly.html-widget {
        height: auto !important;
      }

      .mic-analysis-container > *:not(style) {
        margin-bottom: 1.5rem;
      }

      /* Centerpiece styling for main detection plot */
      .mic-centerpiece {
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border-radius: 16px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        border: 2px solid #dee2e6;
      }

      .mic-centerpiece .card-header {
        background: #ffffff;
        border-bottom: 2px solid #dee2e6;
        color: #2c3e50;
        font-size: 1.25rem;
        font-weight: 600;
        padding: 1.25rem 1.5rem;
      }

      .mic-centerpiece .card-body {
        padding: 1.5rem;
        background: #ffffff;
        border-radius: 0 0 14px 14px;
      }

      /* KPI boxes for detection summary */
      .mic-kpi-box {
        background: #f8f9fa;
        border-radius: 12px;
        padding: 1rem 1.25rem;
        text-align: center;
        border: 1px solid #dee2e6;
        transition: transform 0.2s ease;
      }

      .mic-kpi-box:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      }

      .mic-kpi-value {
        font-size: 2rem;
        font-weight: 700;
        margin-bottom: 0.25rem;
      }

      .mic-kpi-label {
        font-size: 0.85rem;
        color: #6c757d;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .mic-kpi-positive { color: #2ecc71; }
      .mic-kpi-negative { color: #7f8c8d; }
      .mic-kpi-dna { color: #3498db; }
      .mic-kpi-rna { color: #9b59b6; }
      .mic-kpi-late { color: #f39c12; }

      /* Section headers */
      .mic-section-header {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        margin-top: 2rem;
        margin-bottom: 1.25rem;
        padding-bottom: 0.5rem;
        border-bottom: 2px solid #e9ecef;
      }

      .mic-section-header h4 {
        margin: 0;
        font-weight: 600;
        color: #2c3e50;
      }

      .mic-section-icon {
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #3498db;
        color: white;
        border-radius: 8px;
        font-size: 1rem;
      }

      /* Sample statistics table styling */
      .mic-stats-table {
        font-size: 0.9rem;
      }

      .mic-stats-table th {
        background: #f8f9fa;
        font-weight: 600;
        border-bottom: 2px solid #dee2e6;
      }

      .mic-stats-table .positive-row {
        background: rgba(46, 204, 113, 0.1);
      }

      .mic-stats-table .sd-cell {
        font-family: monospace;
        color: #7f8c8d;
      }
      "
    )),
    div(
      class = "container-fluid mic-analysis-container pb-4",

      # === SECTION 1: CENTERPIECE - Trypanozoon Detection ===
      div(class = "mic-section-header mt-3",
        div(class = "mic-section-icon", bsicons::bs_icon("bullseye")),
        h4("Trypanozoon Detection Results")
      ),

      # Main detection scatter - FULL WIDTH CENTERPIECE
      card(
        class = "mic-plot-card mic-centerpiece",
        card_header(
          div(
            class = "d-flex justify-content-between align-items-center",
            span("18S2 (RNA) vs 177T (DNA) Detection"),
            div(
              class = "d-flex gap-2",
              checkboxInput(
                ns("show_consolidated_only"),
                span("Show final consolidated results only", style = "color: white; font-size: 0.85rem;"),
                value = TRUE,
                width = "auto"
              )
            )
          )
        ),
        card_body(
          # KPI Summary Row
          div(
            class = "d-flex flex-wrap gap-3 mb-4 justify-content-center",
            uiOutput(ns("detection_kpis"))
          ),
          # Main scatter plot - LARGE
          plotlyOutput(ns("scatter_tryp"), height = "600px"),
          # Legend explanation
          div(
            class = "mt-3 text-center",
            style = "color: #6c757d; font-size: 0.85rem;",
            HTML("Lower Cq = stronger detection &bull; Points at Cq 40 = No detection &bull; ◆ Diamond = retested sample")
          ),
          class = "p-3"
        )
      ),

      # === SECTION 2: Cq Distributions - PROMINENT ===
      div(class = "mic-section-header",
        div(class = "mic-section-icon", style = "background: #9b59b6;", bsicons::bs_icon("bar-chart-fill")),
        h4("Cq Value Distributions by Final Call")
      ),

      # Cq Distribution by Final Call - FULL WIDTH, LARGER
      card(
        class = "mic-plot-card",
        card_header(
          div(
            class = "d-flex justify-content-between align-items-center",
            span("Cq Distribution Analysis"),
            div(
              class = "text-muted small",
              "Each box shows median, IQR, and outliers for samples in that category"
            )
          )
        ),
        card_body(
          plotlyOutput(ns("box_cq_by_call"), height = "550px"),
          class = "p-3"
        ),
        card_footer(
          class = "bg-light p-3",
          div(
            class = "text-muted mb-2",
            tags$strong("Statistical Summary: "),
            "Comparing RNAseP Cq values across detection categories (Kruskal-Wallis & pairwise Mann-Whitney tests)"
          ),
          tableOutput(ns("rnasep_stats_table"))
        )
      ),

      # Secondary: Distribution by Target (smaller)
      card(
        class = "mic-plot-card mt-3",
        card_header("Cq Distribution by Target"),
        card_body(
          plotlyOutput(ns("box_cq_by_target"), height = "400px"),
          class = "p-3"
        )
      ),

      # === SECTION 3: Sample Statistics with SD ===
      div(class = "mic-section-header",
        div(class = "mic-section-icon", style = "background: #27ae60;", bsicons::bs_icon("table")),
        h4("Sample-Level Statistics")
      ),

      card(
        class = "mic-plot-card",
        card_header("Positive Samples with Replicate Statistics"),
        card_body(
          div(
            class = "mb-3 text-muted",
            "Showing Cq values (Mean ± SD) for positive samples. CV% indicates replicate consistency."
          ),
          div(
            style = "max-height: 500px; overflow-y: auto;",
            tableOutput(ns("sample_stats_table"))
          ),
          class = "p-3"
        )
      ),

      # === SECTION 4: Retest Analysis (Sankey kept) ===
      div(class = "mic-section-header",
        div(class = "mic-section-icon", style = "background: #e67e22;", bsicons::bs_icon("arrow-repeat")),
        h4("Retest & Follow-up Analysis")
      ),

      card(
        class = "mic-plot-card",
        card_header("Sample Testing Frequency & Transitions"),
        card_body(
          div(
            class = "d-flex flex-column flex-lg-row gap-2 align-items-lg-center justify-content-lg-between mb-3",
            div(
              class = "flex-grow-1",
              textOutput(ns("sample_repeat_caption"))
            ),
            div(
              class = "ms-lg-3",
              checkboxInput(
                ns("show_latest_followup"),
                "Focus on the latest follow-up when a sample was retested",
                value = FALSE
              )
            )
          ),
          tableOutput(ns("sample_repeat_table")),
          hr(),
          div(
            class = "mt-3 mb-2",
            textOutput(ns("sample_transition_caption"))
          ),
          div(
            class = "mb-3",
            plotlyOutput(ns("sample_transition_sankey"), height = "360px")
          ),
          tableOutput(ns("sample_transition_table")),
          class = "p-3"
        )
      ),

      # === SECTION 5: Quality Metrics ===
      div(class = "mic-section-header",
        div(class = "mic-section-icon", style = "background: #e74c3c;", bsicons::bs_icon("shield-check")),
        h4("Quality Control Metrics")
      ),

      layout_column_wrap(
        width = 1/3,
        gap = "16px",
        heights_equal = "row",

        card(
          class = "mic-plot-card",
          card_header("RNA Preservation Distribution"),
          card_body(
            plotlyOutput(ns("hist_delta_rp"), height = "400px"),
            class = "p-3"
          )
        ),

        card(
          class = "mic-plot-card",
          card_header("RNA Quality by Detection"),
          card_body(
            plotlyOutput(ns("violin_quality"), height = "400px"),
            class = "p-3"
          )
        ),

        card(
          class = "mic-plot-card",
          card_header("QC Pass Rates by Call"),
          card_body(
            plotlyOutput(ns("bar_qc_rates"), height = "400px"),
            class = "p-3"
          )
        )
      ),

      # === SECTION 6: Clinical Decision Matrix ===
      div(class = "mic-section-header",
        div(class = "mic-section-icon", style = "background: #2c3e50;", bsicons::bs_icon("clipboard2-check")),
        h4("Clinical Decision Validation")
      ),

      layout_column_wrap(
        width = 1/2,
        gap = "16px",
        heights_equal = "row",

        card(
          class = "mic-plot-card",
          card_header("Detection Pattern vs Final Call"),
          card_body(
            plotlyOutput(ns("heatmap_decision_matrix"), height = "450px"),
            class = "p-3"
          )
        ),

        card(
          class = "mic-plot-card",
          card_header("ΔCq Distribution: 18S2 - 177T"),
          card_body(
            plotlyOutput(ns("hist_delta_tryp"), height = "450px"),
            class = "p-3"
          )
        )
      ),

      # === SECTION 7: Temporal and Geographic ===
      div(class = "mic-section-header",
        div(class = "mic-section-icon", style = "background: #1abc9c;", bsicons::bs_icon("geo-alt-fill")),
        h4("Trends and Geographic Analysis")
      ),

      card(
        class = "mic-plot-card",
        card_header("Temporal Trends: Volume and Positivity"),
        card_body(
          plotlyOutput(ns("line_temporal"), height = "400px"),
          class = "p-3"
        )
      ),

      layout_column_wrap(
        width = 1/2,
        gap = "16px",
        heights_equal = "row",
        class = "mt-3",

        card(
          class = "mic-plot-card",
          card_header("Positivity by Structure Sanitaire"),
          card_body(
            plotlyOutput(ns("bar_geo_positivity"), height = "500px"),
            class = "p-3"
          )
        ),

        card(
          class = "mic-plot-card",
          card_header("RNA Quality by Structure Sanitaire"),
          card_body(
            plotlyOutput(ns("box_geo_quality"), height = "500px"),
            class = "p-3"
          )
        )
      )
    )
  )
}

mod_mic_analysis_server <- function(id, filtered_base, filtered_replicates = NULL) {
  moduleServer(id, function(input, output, session) {

    # === Detection KPI Summary ===
    output$detection_kpis <- renderUI({
      df <- filtered_base()

      if (is.null(df) || !nrow(df)) {
        return(NULL)
      }

      samples <- df %>%
        filter(ControlType == "Sample")

      # If showing consolidated only, get unique samples by final status
      if (isTRUE(input$show_consolidated_only)) {
        sample_id_col <- if ("SampleID" %in% names(samples)) "SampleID" else "SampleName"

        # Get the latest result per sample (or consolidated if available)
        if ("mic_status_final" %in% names(samples)) {
          samples <- samples %>%
            group_by(across(all_of(sample_id_col))) %>%
            slice_tail(n = 1) %>%
            ungroup() %>%
            mutate(FinalCall = coalesce(mic_status_final, FinalCall))
        } else {
          samples <- samples %>%
            group_by(across(all_of(sample_id_col))) %>%
            slice_tail(n = 1) %>%
            ungroup()
        }
      }

      total <- nrow(samples)
      positive <- sum(samples$FinalCall == "Positive", na.rm = TRUE)
      positive_dna <- sum(samples$FinalCall == "Positive_DNA", na.rm = TRUE)
      positive_rna <- sum(samples$FinalCall == "Positive_RNA", na.rm = TRUE)
      late_positive <- sum(samples$FinalCall == "LatePositive", na.rm = TRUE)
      negative <- sum(samples$FinalCall == "Negative", na.rm = TRUE)

      all_positive <- positive + positive_dna + positive_rna + late_positive

      tagList(
        div(class = "mic-kpi-box",
          div(class = "mic-kpi-value", format(total, big.mark = ",")),
          div(class = "mic-kpi-label", "Total Samples")
        ),
        div(class = "mic-kpi-box",
          div(class = "mic-kpi-value mic-kpi-positive", positive),
          div(class = "mic-kpi-label", "Positive (Both)")
        ),
        div(class = "mic-kpi-box",
          div(class = "mic-kpi-value mic-kpi-dna", positive_dna),
          div(class = "mic-kpi-label", "DNA Only")
        ),
        div(class = "mic-kpi-box",
          div(class = "mic-kpi-value mic-kpi-rna", positive_rna),
          div(class = "mic-kpi-label", "RNA Only")
        ),
        div(class = "mic-kpi-box",
          div(class = "mic-kpi-value mic-kpi-late", late_positive),
          div(class = "mic-kpi-label", "Late Positive")
        ),
        div(class = "mic-kpi-box",
          div(class = "mic-kpi-value mic-kpi-negative", negative),
          div(class = "mic-kpi-label", "Negative")
        ),
        div(class = "mic-kpi-box",
          div(class = "mic-kpi-value", style = "color: #f39c12;",
              format_count_with_denominator(all_positive, total, format_style = "full")),
          div(class = "mic-kpi-label", "Positivity Rate")
        )
      )
    })

    # Trypanozoon scatter plot - REDESIGNED CENTERPIECE
    output$scatter_tryp <- renderPlotly({
      tryCatch({
        df <- filtered_base()

        if (is.null(df) || !nrow(df)) {
          return(plotly_empty() %>% layout(title = list(text = "No data available", font = list(color = "white"))))
        }

        required_cols <- c("ControlType", "Cq_median_177T", "Cq_median_18S2", "FinalCall", "SampleName")
        missing_cols <- setdiff(required_cols, names(df))

        if (length(missing_cols) > 0) {
          return(plotly_empty() %>%
                   layout(title = list(text = paste("Missing columns:", paste(missing_cols, collapse = ", ")), font = list(color = "white"))))
        }

        df <- df %>%
          filter(
            ControlType == "Sample",
            !is.na(Cq_median_177T) | !is.na(Cq_median_18S2)
          )

        if (!nrow(df)) {
          return(plotly_empty() %>% layout(title = list(text = "No samples with 177T or 18S2 data", font = list(color = "white"))))
        }

        # Identify samples that were tested multiple times
        sample_id_col <- if ("SampleID" %in% names(df)) "SampleID" else "SampleName"

        df <- df %>%
          group_by(across(all_of(sample_id_col))) %>%
          mutate(
            test_count = n(),
            is_retested = test_count > 1,
            test_order = row_number()
          ) %>%
          ungroup()

        # If showing consolidated only, get the latest/final result per sample
        if (isTRUE(input$show_consolidated_only)) {
          if ("mic_status_final" %in% names(df)) {
            df <- df %>%
              group_by(across(all_of(sample_id_col))) %>%
              slice_tail(n = 1) %>%
              ungroup() %>%
              mutate(FinalCall = coalesce(mic_status_final, FinalCall))
          } else {
            df <- df %>%
              group_by(across(all_of(sample_id_col))) %>%
              slice_tail(n = 1) %>%
              ungroup()
          }
        }

        df <- df %>%
          mutate(
            # Replace NA with high Cq value to show "no detection" on plot
            Cq_median_177T_plot = if_else(is.na(Cq_median_177T), 40.0, Cq_median_177T),
            Cq_median_18S2_plot = if_else(is.na(Cq_median_18S2), 40.0, Cq_median_18S2),
            # Clean detection labels
            Detection_177T = if_else(is.na(Cq_median_177T) | Cq_median_177T >= 40, "Not Detected", "Detected"),
            Detection_18S2 = if_else(is.na(Cq_median_18S2) | Cq_median_18S2 >= 40, "Not Detected", "Detected"),
            # Clean Final Call labels for display
            FinalCall_Display = case_when(
              FinalCall == "Positive" ~ "Positive (Both Markers)",
              FinalCall == "Positive_DNA" ~ "Positive (DNA Only)",
              FinalCall == "Positive_RNA" ~ "Positive (RNA Only)",
              FinalCall == "LatePositive" ~ "Late Positive",
              FinalCall == "Negative" ~ "Negative",
              FinalCall == "Indeterminate" ~ "Indeterminate",
              FinalCall == "Invalid_NoDNA" ~ "Invalid (No DNA)",
              TRUE ~ FinalCall
            ),
            # Prepare hover text with clean formatting
            hover_text = paste0(
              "<b>", SampleName, "</b><br>",
              "<br><b>177T (DNA):</b> ", Detection_177T,
              if_else(Detection_177T == "Detected", paste0(" (Cq ", sprintf("%.1f", Cq_median_177T), ")"), ""),
              "<br><b>18S2 (RNA):</b> ", Detection_18S2,
              if_else(Detection_18S2 == "Detected", paste0(" (Cq ", sprintf("%.1f", Cq_median_18S2), ")"), ""),
              "<br><br><b>Final Call:</b> ", FinalCall_Display,
              if_else(is_retested, paste0("<br><i>Tested ", test_count, " times</i>"), "")
            )
          )

        # Color palette for final calls
        call_colors <- c(
          "Positive" = "#2ecc71",
          "Positive_DNA" = "#3498db",
          "Positive_RNA" = "#9b59b6",
          "LatePositive" = "#f39c12",
          "Negative" = "#95a5a6",
          "Indeterminate" = "#e67e22",
          "Invalid_NoDNA" = "#e74c3c"
        )

        # Create symbol column with proper labels (not TRUE/FALSE)
        df <- df %>%
          mutate(
            SymbolType = if_else(is_retested, "Retested", "Single Test"),
            # Combine FinalCall and retest status for proper marker assignment
            marker_symbol = if_else(is_retested, "diamond", "circle")
          )

        # Build plot by adding traces for each FinalCall category
        fig <- plot_ly()

        for (call_type in names(call_colors)) {
          call_data <- df %>% filter(FinalCall == call_type)
          if (nrow(call_data) > 0) {
            # Single test samples (circles)
            single_data <- call_data %>% filter(!is_retested)
            if (nrow(single_data) > 0) {
              fig <- fig %>%
                add_trace(
                  data = single_data,
                  x = ~Cq_median_177T_plot,
                  y = ~Cq_median_18S2_plot,
                  type = 'scatter',
                  mode = 'markers',
                  name = call_type,
                  legendgroup = call_type,
                  hovertext = ~hover_text,
                  hoverinfo = 'text',
                  marker = list(
                    symbol = "circle",
                    size = 12,
                    opacity = 0.85,
                    color = call_colors[[call_type]],
                    line = list(width = 1.5, color = "#ffffff")
                  )
                )
            }

            # Retested samples (diamonds) - same color, no separate legend entry
            retest_data <- call_data %>% filter(is_retested)
            if (nrow(retest_data) > 0) {
              fig <- fig %>%
                add_trace(
                  data = retest_data,
                  x = ~Cq_median_177T_plot,
                  y = ~Cq_median_18S2_plot,
                  type = 'scatter',
                  mode = 'markers',
                  name = call_type,
                  legendgroup = call_type,
                  showlegend = FALSE,  # Don't add separate legend entry
                  hovertext = ~hover_text,
                  hoverinfo = 'text',
                  marker = list(
                    symbol = "diamond",
                    size = 14,
                    opacity = 0.9,
                    color = call_colors[[call_type]],
                    line = list(width = 2, color = "#ffffff")
                  )
                )
            }
          }
        }

        fig %>%
          layout(
            xaxis = list(
              title = list(text = "177T Cq (DNA Detection)", font = list(size = 14)),
              gridcolor = "#e9ecef",
              zerolinecolor = "#dee2e6",
              range = c(15, 42),
              dtick = 5
            ),
            yaxis = list(
              title = list(text = "18S2 Cq (RNA Detection)", font = list(size = 14)),
              gridcolor = "#e9ecef",
              zerolinecolor = "#dee2e6",
              range = c(15, 42),
              dtick = 5
            ),
            legend = list(
              title = list(text = "Final Call"),
              orientation = "v",
              x = 1.02,
              y = 0.5
            ),
            paper_bgcolor = "rgba(0,0,0,0)",
            plot_bgcolor = "#ffffff",
            hovermode = 'closest',
            # Add quadrant reference lines at Cq 35 (typical threshold)
            shapes = list(
              list(type = "line", x0 = 35, x1 = 35, y0 = 15, y1 = 42,
                   line = list(color = "#adb5bd", dash = "dash", width = 1.5)),
              list(type = "line", x0 = 15, x1 = 42, y0 = 35, y1 = 35,
                   line = list(color = "#adb5bd", dash = "dash", width = 1.5))
            ),
            annotations = list(
              list(x = 25, y = 25, text = "BOTH DETECTED", showarrow = FALSE,
                   font = list(color = "#2ecc71", size = 13, family = "Arial Black")),
              list(x = 25, y = 38, text = "DNA ONLY", showarrow = FALSE,
                   font = list(color = "#3498db", size = 13, family = "Arial Black")),
              list(x = 38, y = 25, text = "RNA ONLY", showarrow = FALSE,
                   font = list(color = "#9b59b6", size = 13, family = "Arial Black")),
              list(x = 38, y = 38, text = "NOT DETECTED", showarrow = FALSE,
                   font = list(color = "#7f8c8d", size = 13, family = "Arial Black"))
            )
          )
      }, error = function(e) {
        plotly_empty() %>%
          layout(
            title = list(text = "Error rendering plot"),
            paper_bgcolor = "rgba(0,0,0,0)",
            plot_bgcolor = "#ffffff",
            annotations = list(
              list(
                text = paste0("Error: ", conditionMessage(e)),
                showarrow = FALSE,
                x = 0.5, y = 0.5,
                xref = "paper", yref = "paper",
                font = list(color = "#e74c3c", size = 14)
              )
            )
          )
      })
    })

    # === NEW: Sample Statistics Table with SD ===
    output$sample_stats_table <- renderTable({
      replicates <- if (is.null(filtered_replicates)) tibble() else filtered_replicates()
      base <- filtered_base()

      if (!nrow(replicates) || !nrow(base)) {
        return(tibble(Message = "No replicate data available"))
      }

      # Get positive samples from base data
      positive_samples <- base %>%
        filter(ControlType == "Sample", grepl("Positive", FinalCall)) %>%
        pull(SampleName) %>%
        unique()

      if (!length(positive_samples)) {
        return(tibble(Message = "No positive samples found"))
      }

      # Calculate statistics for positive samples
      target_map <- c("177T" = "177T", "18S2" = "18S2")

      stats <- replicates %>%
        filter(
          ControlType == "Sample",
          SampleName %in% positive_samples,
          Target %in% names(target_map),
          !is.na(Cq)
        ) %>%
        mutate(TargetLabel = target_map[Target]) %>%
        group_by(SampleName, TargetLabel) %>%
        summarise(
          n_reps = n(),
          mean_cq = mean(Cq, na.rm = TRUE),
          sd_cq = sd(Cq, na.rm = TRUE),
          cv_pct = if_else(mean_cq > 0, 100 * sd_cq / mean_cq, NA_real_),
          .groups = "drop"
        ) %>%
        mutate(
          Cq_display = case_when(
            is.na(sd_cq) | n_reps < 2 ~ sprintf("%.1f", mean_cq),
            TRUE ~ sprintf("%.1f ± %.2f", mean_cq, sd_cq)
          ),
          CV_display = if_else(is.na(cv_pct), "-", sprintf("%.1f%%", cv_pct))
        )

      # Pivot to wide format
      stats_wide <- stats %>%
        select(SampleName, TargetLabel, Cq_display, CV_display) %>%
        tidyr::pivot_wider(
          names_from = TargetLabel,
          values_from = c(Cq_display, CV_display),
          names_glue = "{TargetLabel}_{.value}"
        )

      # Add final call from base
      final_calls <- base %>%
        filter(SampleName %in% positive_samples) %>%
        group_by(SampleName) %>%
        slice_tail(n = 1) %>%
        ungroup() %>%
        select(SampleName, FinalCall)

      result <- stats_wide %>%
        left_join(final_calls, by = "SampleName") %>%
        select(
          Sample = SampleName,
          `Final Call` = FinalCall,
          `177T Cq (Mean ± SD)` = `177T_Cq_display`,
          `177T CV%` = `177T_CV_display`,
          `18S2 Cq (Mean ± SD)` = `18S2_Cq_display`,
          `18S2 CV%` = `18S2_CV_display`
        ) %>%
        arrange(`Final Call`, Sample)

      # Replace NA with "-"
      result <- result %>%
        mutate(across(everything(), ~if_else(is.na(.), "-", as.character(.))))

      result
    },
    striped = TRUE,
    bordered = TRUE,
    hover = TRUE,
    spacing = "s",
    align = "l",
    rownames = FALSE)
    
    # RNAseP quality scatter plot
    output$scatter_rnp <- renderPlotly({
      tryCatch({
        df <- filtered_base()

        if (is.null(df) || !nrow(df)) {
          return(plotly_empty() %>% layout(title = "No data available"))
        }

        required_cols <- c("ControlType", "Cq_median_RNAseP_DNA", "Cq_median_RNAseP_RNA", "SampleName", "Delta_RP")
        missing_cols <- setdiff(required_cols, names(df))

        if (length(missing_cols) > 0) {
          return(plotly_empty() %>%
                   layout(title = paste("Missing columns:", paste(missing_cols, collapse = ", "))))
        }

        df <- df %>%
          filter(
            ControlType == "Sample",
            !is.na(Cq_median_RNAseP_DNA),
            !is.na(Cq_median_RNAseP_RNA)
          ) %>%
          mutate(
            # Primary quality assessment: samples with Cq > 35 are poor quality
            Quality = case_when(
              Cq_median_RNAseP_DNA > 35 | Cq_median_RNAseP_RNA > 35 ~ "Poor Quality (Cq > 35)",
              is.na(Delta_RP) ~ "Unknown",
              Delta_RP <= 5 ~ "Good (ΔCq ≤ 5)",
              Delta_RP <= 8 ~ "Moderate (ΔCq ≤ 8)",
              TRUE ~ "Poor (ΔCq > 8)"
            ),
            # Reorder factor levels to prioritize poor quality
            Quality = factor(Quality, levels = c(
              "Good (ΔCq ≤ 5)",
              "Moderate (ΔCq ≤ 8)",
              "Poor (ΔCq > 8)",
              "Poor Quality (Cq > 35)",
              "Unknown"
            ))
          )

        if (!nrow(df)) {
          return(plotly_empty() %>% layout(title = "No samples with RNAseP data"))
        }

        plot_ly(df, x = ~Cq_median_RNAseP_DNA, y = ~Cq_median_RNAseP_RNA,
                color = ~Quality,
                colors = c(
                  "Good (ΔCq ≤ 5)" = "#27ae60",
                  "Moderate (ΔCq ≤ 8)" = "#f39c12",
                  "Poor (ΔCq > 8)" = "#e67e22",
                  "Poor Quality (Cq > 35)" = "#e74c3c",
                  "Unknown" = "#95a5a6"
                ),
                type = 'scatter', mode = 'markers',
                text = ~paste0(
                  SampleName,
                  "<br>DNA Cq: ", round(Cq_median_RNAseP_DNA, 2),
                  "<br>RNA Cq: ", round(Cq_median_RNAseP_RNA, 2),
                  "<br>ΔCq: ", if_else(is.na(Delta_RP), "N/A", as.character(round(Delta_RP, 2)))
                ),
                marker = list(
                  size = 10,
                  opacity = 0.8,
                  line = list(width = 1, color = "white")  # Small white border for definition
                )) %>%
          layout(
            xaxis = list(
              title = "RNAseP-DNA Cq",
              range = c(15, 40),
              zeroline = FALSE
            ),
            yaxis = list(
              title = "RNAseP-RNA Cq",
              range = c(15, 40),
              zeroline = FALSE
            ),
            legend = list(title = list(text = "Quality")),
            hovermode = 'closest',
            shapes = list(
              # Vertical line at Cq = 35 for DNA
              list(
                type = "line",
                x0 = 35, x1 = 35,
                y0 = 15, y1 = 40,
                line = list(color = "red", dash = "dash", width = 2)
              ),
              # Horizontal line at Cq = 35 for RNA
              list(
                type = "line",
                x0 = 15, x1 = 40,
                y0 = 35, y1 = 35,
                line = list(color = "red", dash = "dash", width = 2)
              )
            ),
            annotations = list(
              list(
                x = 35, y = 39,
                text = "Poor Quality Threshold (Cq = 35)",
                showarrow = FALSE,
                xanchor = "left",
                font = list(color = "red", size = 10)
              )
            )
          )
      }, error = function(e) {
        plotly_empty() %>%
          layout(
            title = "Error rendering plot",
            annotations = list(
              list(
                text = paste0("Error: ", conditionMessage(e),
                             "<br><br>Please check the console for details."),
                showarrow = FALSE,
                x = 0.5,
                y = 0.5,
                xref = "paper",
                yref = "paper",
                font = list(color = "red", size = 14)
              )
            )
          )
      })
    })
    
    # Delta histograms
    output$hist_delta_tryp <- renderPlotly({
      df <- filtered_base() %>%
        filter(ControlType == "Sample", !is.na(Delta_18S2_177T))
      
      if (!nrow(df)) {
        return(plotly_empty() %>% layout(title = "No delta data"))
      }
      
      plot_ly(df, x = ~Delta_18S2_177T, type = 'histogram',
              marker = list(color = '#3498db', line = list(color = 'white', width = 1))) %>%
        layout(
          xaxis = list(title = "ΔCq (18S2 - 177T)"),
          yaxis = list(title = "Count"),
          bargap = 0.1
        )
    })
    
    output$hist_delta_rp <- renderPlotly({
      df <- filtered_base() %>%
        filter(ControlType == "Sample", !is.na(Delta_RP))

      if (!nrow(df)) {
        return(plotly_empty() %>% layout(title = "No RNA preservation data"))
      }

      plot_ly(df, x = ~Delta_RP, type = 'histogram',
              marker = list(color = '#e74c3c', line = list(color = 'white', width = 1))) %>%
        layout(
          title = paste0("n = ", nrow(df)),
          xaxis = list(title = "ΔCq (RNA - DNA)"),
          yaxis = list(title = "Count"),
          bargap = 0.1,
          shapes = list(
            list(
              type = "line",
              x0 = 5, x1 = 5,
              y0 = 0, y1 = 1,
              yref = "paper",
              line = list(color = 'green', dash = 'dash', width = 2)
            ),
            list(
              type = "line",
              x0 = 8, x1 = 8,
              y0 = 0, y1 = 1,
              yref = "paper",
              line = list(color = 'orange', dash = 'dash', width = 2)
            )
          ),
          annotations = list(
            list(x = 5, y = 0.95, text = "Good", showarrow = FALSE, yref = "paper"),
            list(x = 6.5, y = 0.95, text = "Moderate", showarrow = FALSE, yref = "paper"),
            list(x = 9, y = 0.95, text = "Poor", showarrow = FALSE, yref = "paper")
          )
        )
    })

    # === NEW: Cq Distribution by Target ===
    output$box_cq_by_target <- renderPlotly({
      df <- filtered_base() %>%
        filter(ControlType == "Sample")

      if (!nrow(df)) {
        return(plotly_empty() %>% layout(title = "No data available"))
      }

      # Reshape to long format
      df_long <- df %>%
        select(SampleName,
               `177T` = Cq_median_177T,
               `18S2` = Cq_median_18S2,
               `RNAseP-DNA` = Cq_median_RNAseP_DNA,
               `RNAseP-RNA` = Cq_median_RNAseP_RNA) %>%
        tidyr::pivot_longer(cols = -SampleName, names_to = "Target", values_to = "Cq") %>%
        filter(!is.na(Cq))

      if (!nrow(df_long)) {
        return(plotly_empty() %>% layout(title = "No Cq data available"))
      }

      plot_ly(df_long, x = ~Target, y = ~Cq, color = ~Target,
              type = "box",
              colors = c("177T" = "#3498db", "18S2" = "#9b59b6",
                        "RNAseP-DNA" = "#27ae60", "RNAseP-RNA" = "#e74c3c")) %>%
        layout(
          title = paste0("n = ", length(unique(df_long$SampleName)), " samples"),
          xaxis = list(title = ""),
          yaxis = list(title = "Cq Value"),
          showlegend = FALSE
        )
    })

    # === Cq Distribution by Call - REDESIGNED FOR PROMINENCE ===
    output$box_cq_by_call <- renderPlotly({
      df <- filtered_base() %>%
        filter(ControlType == "Sample", !is.na(FinalCall))

      if (!nrow(df)) {
        return(plotly_empty() %>% layout(title = "No data available"))
      }

      # Include all four markers: Trypanozoon (177T, 18S2) and RNAseP quality controls
      df_long <- df %>%
        select(SampleName, FinalCall,
               `177T (DNA)` = Cq_median_177T,
               `18S2 (RNA)` = Cq_median_18S2,
               `RNAseP-DNA` = Cq_median_RNAseP_DNA,
               `RNAseP-RNA` = Cq_median_RNAseP_RNA) %>%
        tidyr::pivot_longer(cols = c(`177T (DNA)`, `18S2 (RNA)`, `RNAseP-DNA`, `RNAseP-RNA`),
                           names_to = "Marker", values_to = "Cq") %>%
        filter(!is.na(Cq)) %>%
        mutate(
          # Clean labels for Final Call
          FinalCall_Label = case_when(
            FinalCall == "Positive" ~ "Positive\n(Both)",
            FinalCall == "Positive_DNA" ~ "Positive\n(DNA)",
            FinalCall == "Positive_RNA" ~ "Positive\n(RNA)",
            FinalCall == "Negative" ~ "Negative",
            FinalCall == "Indeterminate" ~ "Indeterminate",
            FinalCall == "Invalid_NoDNA" ~ "Invalid",
            TRUE ~ FinalCall
          ),
          # Order factor by clinical importance
          FinalCall_Label = factor(FinalCall_Label, levels = c(
            "Positive\n(Both)", "Positive\n(DNA)", "Positive\n(RNA)",
            "Indeterminate", "Negative", "Invalid"
          ))
        )

      if (!nrow(df_long)) {
        return(plotly_empty() %>% layout(title = "No Cq data available"))
      }

      # Count samples per category for annotation
      sample_counts <- df %>%
        mutate(
          FinalCall_Label = case_when(
            FinalCall == "Positive" ~ "Positive\n(Both)",
            FinalCall == "Positive_DNA" ~ "Positive\n(DNA)",
            FinalCall == "Positive_RNA" ~ "Positive\n(RNA)",
            FinalCall == "Negative" ~ "Negative",
            FinalCall == "Indeterminate" ~ "Indeterminate",
            FinalCall == "Invalid_NoDNA" ~ "Invalid",
            TRUE ~ FinalCall
          )
        ) %>%
        count(FinalCall_Label, name = "n")

      # Create a faceted box plot - more visually impactful
      fig <- plot_ly()

      # Add traces for each marker - grouped by type for visual clarity
      marker_colors <- c(
        "177T (DNA)" = "#3498db",    # Blue - Trypanozoon DNA
        "18S2 (RNA)" = "#9b59b6",    # Purple - Trypanozoon RNA
        "RNAseP-DNA" = "#27ae60",    # Green - Quality control DNA
        "RNAseP-RNA" = "#e74c3c"     # Red - Quality control RNA
      )

      for (marker in c("177T (DNA)", "18S2 (RNA)", "RNAseP-DNA", "RNAseP-RNA")) {
        marker_data <- df_long %>% filter(Marker == marker)

        fig <- fig %>%
          add_trace(
            data = marker_data,
            x = ~FinalCall_Label,
            y = ~Cq,
            type = "box",
            name = marker,
            marker = list(color = marker_colors[[marker]]),
            line = list(color = marker_colors[[marker]]),
            fillcolor = paste0(marker_colors[[marker]], "40"),  # 40 = 25% opacity
            boxpoints = "outliers",
            jitter = 0.3,
            pointpos = 0,
            hovertemplate = paste0(
              "<b>", marker, "</b><br>",
              "Category: %{x}<br>",
              "Cq: %{y:.1f}<br>",
              "<extra></extra>"
            )
          )
      }

      # Add threshold reference lines
      fig <- fig %>%
        layout(
          title = list(
            text = paste0("<b>Cq Distribution by Final Call</b><br>",
                         "<sup>n = ", length(unique(df_long$SampleName)), " samples | ",
                         "Trypanozoon (177T, 18S2) + Quality Controls (RNAseP)</sup>"),
            font = list(size = 16),
            y = 0.97
          ),
          xaxis = list(
            title = "",
            tickfont = list(size = 11),
            categoryorder = "array",
            categoryarray = c("Positive\n(Both)", "Positive\n(DNA)", "Positive\n(RNA)",
                             "Indeterminate", "Negative", "Invalid")
          ),
          yaxis = list(
            title = "Cq Value",
            titlefont = list(size = 13),
            range = c(10, 45),
            dtick = 5
          ),
          boxmode = "group",
          boxgap = 0.3,
          boxgroupgap = 0.1,
          legend = list(
            title = list(text = "Marker"),
            orientation = "h",
            x = 0.5,
            xanchor = "center",
            y = -0.12
          ),
          margin = list(t = 80, b = 80),
          # Add reference lines for thresholds
          shapes = list(
            list(type = "line", x0 = -0.5, x1 = 5.5, y0 = 35, y1 = 35,
                 line = list(color = "#f39c12", dash = "dash", width = 2)),
            list(type = "line", x0 = -0.5, x1 = 5.5, y0 = 40, y1 = 40,
                 line = list(color = "#e74c3c", dash = "dot", width = 2))
          ),
          annotations = list(
            list(x = 1.02, y = 35, xref = "paper", text = "Positive threshold (≤35)",
                 showarrow = FALSE, font = list(color = "#f39c12", size = 10)),
            list(x = 1.02, y = 40, xref = "paper", text = "No detection (≥40)",
                 showarrow = FALSE, font = list(color = "#e74c3c", size = 10))
          )
        )

      fig
    })

    # === RNAseP Statistics Table - Compare across Final Call categories ===
    output$rnasep_stats_table <- renderTable({
      df <- filtered_base() %>%
        filter(ControlType == "Sample", !is.na(FinalCall))

      if (!nrow(df) || nrow(df) < 3) {
        return(data.frame(Message = "Insufficient data for statistical analysis"))
      }

      # Focus on the main detection categories
      df <- df %>%
        filter(FinalCall %in% c("Positive", "Positive_DNA", "Positive_RNA", "Negative")) %>%
        mutate(
          FinalCall_Label = case_when(
            FinalCall == "Positive" ~ "TNA Positive",
            FinalCall == "Positive_DNA" ~ "DNA Positive",
            FinalCall == "Positive_RNA" ~ "RNA Positive",
            FinalCall == "Negative" ~ "Negative",
            TRUE ~ FinalCall
          )
        )

      if (length(unique(df$FinalCall)) < 2) {
        return(data.frame(Message = "Need at least 2 categories for comparison"))
      }

      # Build statistics for each marker
      stats_list <- list()

      for (marker_name in c("RNAseP-DNA", "RNAseP-RNA")) {
        cq_col <- if (marker_name == "RNAseP-DNA") "Cq_median_RNAseP_DNA" else "Cq_median_RNAseP_RNA"

        if (!cq_col %in% names(df)) next

        # Get summary stats per group
        group_stats <- df %>%
          filter(!is.na(.data[[cq_col]])) %>%
          group_by(FinalCall_Label) %>%
          summarise(
            n = n(),
            median = median(.data[[cq_col]], na.rm = TRUE),
            q25 = quantile(.data[[cq_col]], 0.25, na.rm = TRUE),
            q75 = quantile(.data[[cq_col]], 0.75, na.rm = TRUE),
            .groups = "drop"
          )

        if (nrow(group_stats) < 2) next

        # Kruskal-Wallis test (overall comparison)
        valid_data <- df %>% filter(!is.na(.data[[cq_col]]))
        kw_test <- tryCatch(
          kruskal.test(reformulate("FinalCall", cq_col), data = valid_data),
          error = function(e) NULL
        )

        # Pairwise comparisons for key hypotheses
        pairwise_results <- list()

        # DNA Positive vs Negative (expect higher RNAseP-RNA in DNA positives)
        dna_pos <- valid_data %>% filter(FinalCall == "Positive_DNA") %>% pull(cq_col)
        neg <- valid_data %>% filter(FinalCall == "Negative") %>% pull(cq_col)
        if (length(dna_pos) >= 2 && length(neg) >= 2) {
          wt <- tryCatch(wilcox.test(dna_pos, neg), error = function(e) NULL)
          if (!is.null(wt)) {
            pairwise_results[["DNA+ vs Neg"]] <- sprintf("p=%.3f", wt$p.value)
          }
        }

        # TNA Positive vs Negative
        tna_pos <- valid_data %>% filter(FinalCall == "Positive") %>% pull(cq_col)
        if (length(tna_pos) >= 2 && length(neg) >= 2) {
          wt <- tryCatch(wilcox.test(tna_pos, neg), error = function(e) NULL)
          if (!is.null(wt)) {
            pairwise_results[["TNA+ vs Neg"]] <- sprintf("p=%.3f", wt$p.value)
          }
        }

        # DNA Positive vs TNA Positive
        if (length(dna_pos) >= 2 && length(tna_pos) >= 2) {
          wt <- tryCatch(wilcox.test(dna_pos, tna_pos), error = function(e) NULL)
          if (!is.null(wt)) {
            pairwise_results[["DNA+ vs TNA+"]] <- sprintf("p=%.3f", wt$p.value)
          }
        }

        # Build row
        row_data <- data.frame(
          Marker = marker_name,
          stringsAsFactors = FALSE
        )

        # Add median (IQR) for each group
        for (grp in c("TNA Positive", "DNA Positive", "RNA Positive", "Negative")) {
          grp_stat <- group_stats %>% filter(FinalCall_Label == grp)
          if (nrow(grp_stat) > 0) {
            row_data[[grp]] <- sprintf("%.1f (%.1f-%.1f) n=%d",
                                       grp_stat$median, grp_stat$q25, grp_stat$q75, grp_stat$n)
          } else {
            row_data[[grp]] <- "-"
          }
        }

        # Add Kruskal-Wallis p-value
        row_data[["Overall p"]] <- if (!is.null(kw_test)) sprintf("%.4f", kw_test$p.value) else "N/A"

        # Add key pairwise comparison
        row_data[["DNA+ vs Neg"]] <- if (!is.null(pairwise_results[["DNA+ vs Neg"]])) pairwise_results[["DNA+ vs Neg"]] else "-"

        stats_list[[length(stats_list) + 1]] <- row_data
      }

      if (length(stats_list) == 0) {
        return(data.frame(Message = "No RNAseP data available for analysis"))
      }

      result <- do.call(rbind, stats_list)
      result
    }, striped = TRUE, hover = TRUE, bordered = TRUE, spacing = "s")

    # Helper: Sample repeat frequency summary ---------------------------------
    sample_repeat_summary <- reactive({
      df <- filtered_base()

      if (is.null(df) || !nrow(df)) {
        return(NULL)
      }

      if (!"ControlType" %in% names(df)) {
        return(list(message = "Control information is unavailable for the current selection."))
      }

      has_sample_id <- "SampleID" %in% names(df)
      has_sample_name <- "SampleName" %in% names(df)

      if (!has_sample_id && !has_sample_name) {
        return(list(message = "No sample identifiers available to summarise repeats."))
      }

      if (!"RunID" %in% names(df)) {
        return(list(message = "Run identifiers are missing, so repeat testing cannot be calculated."))
      }

      sample_base <- df %>%
        filter(ControlType == "Sample") %>%
        mutate(
          SampleKey = dplyr::coalesce(
            if (has_sample_id) as.character(SampleID) else NA_character_,
            if (has_sample_name) as.character(SampleName) else NA_character_,
            "Unknown sample"
          ),
          RunKey = dplyr::coalesce(as.character(RunID), "Unknown run")
        )

      sample_runs <- sample_base %>%
        distinct(SampleKey, RunKey)

      if (!nrow(sample_runs)) {
        return(list(message = "No samples available after filters are applied."))
      }

      sample_counts <- sample_runs %>%
        count(SampleKey, name = "TimesTested")

      if (!nrow(sample_counts)) {
        return(list(message = "Unable to determine repeat testing counts."))
      }

      distribution <- sample_counts %>%
        count(TimesTested, name = "NumberOfSamples") %>%
        arrange(TimesTested) %>%
        mutate(
          Percent = if (sum(NumberOfSamples) > 0) {
            sprintf("%.1f%%", NumberOfSamples / sum(NumberOfSamples) * 100)
          } else {
            "0.0%"
          }
        )

      repeated_keys <- sample_counts %>%
        filter(TimesTested > 1) %>%
        pull(SampleKey)

      transition_info <- list(
        table = tibble(),
        total_retests = length(repeated_keys),
        total_pairs = 0,
        changed_pairs = 0,
        change_percent = 0,
        missing_pairs = 0,
        top_change = NULL
      )

      if (length(repeated_keys)) {
        sample_history <- sample_base %>%
          filter(SampleKey %in% repeated_keys) %>%
          distinct(SampleKey, RunKey, .keep_all = TRUE) %>%
          mutate(
            RunDateTimeParsed = if ("RunDateTime" %in% names(.)) {
              suppressWarnings(lubridate::ymd_hms(as.character(RunDateTime), tz = "UTC"))
            } else {
              as.POSIXct(NA)
            },
            RunDateParsed = if ("RunDate" %in% names(.)) {
              suppressWarnings(lubridate::ymd(as.character(RunDate)))
            } else {
              as.Date(NA)
            }
          ) %>%
          arrange(SampleKey, RunDateTimeParsed, RunDateParsed, RunKey) %>%
          group_by(SampleKey) %>%
          mutate(TestNumber = dplyr::row_number()) %>%
          ungroup()

        consecutive_pairs <- sample_history %>%
          arrange(SampleKey, TestNumber) %>%
          group_by(SampleKey) %>%
          mutate(
            NextCall = lead(FinalCall),
            NextTestNumber = lead(TestNumber)
          ) %>%
          ungroup() %>%
          filter(!is.na(NextTestNumber))

        # If show_latest_followup is TRUE, filter to only the last transition per sample
        if (isTRUE(input$show_latest_followup)) {
          consecutive_pairs <- consecutive_pairs %>%
            group_by(SampleKey) %>%
            filter(TestNumber == max(TestNumber) - 1) %>%
            ungroup()
        }

        if (nrow(consecutive_pairs)) {
          valid_pairs <- consecutive_pairs %>%
            filter(!is.na(FinalCall) & !is.na(NextCall))

          changed_pairs <- valid_pairs %>%
            filter(FinalCall != NextCall)

          transition_raw <- consecutive_pairs %>%
            transmute(
              `Primary Call` = tidyr::replace_na(FinalCall, "No Result"),
              `Secondary Call` = tidyr::replace_na(NextCall, "No Result")
            ) %>%
            count(`Primary Call`, `Secondary Call`, name = "Samples") %>%
            arrange(desc(Samples))

          transition_table <- transition_raw %>%
            mutate(
              `Percent of Retests` = if (sum(Samples) > 0) {
                sprintf("%.1f%%", Samples / sum(Samples) * 100)
              } else {
                "0.0%"
              }
            ) %>%
            transmute(
              `Primary Call` = `Primary Call`,
              `Secondary Call` = `Secondary Call`,
              `Number of Samples` = Samples,
              `Percent of Retests`
            )

          top_change_row <- transition_raw %>%
            filter(`Primary Call` != `Secondary Call`) %>%
            slice_head(n = 1)

          top_change <- if (nrow(top_change_row)) {
            list(
              primary = top_change_row$`Primary Call`[1],
              secondary = top_change_row$`Secondary Call`[1],
              samples = top_change_row$Samples[1]
            )
          } else {
            NULL
          }

          transition_info <- list(
            table = transition_table,
            raw = transition_raw,
            total_retests = length(unique(consecutive_pairs$SampleKey)),
            total_pairs = nrow(valid_pairs),
            changed_pairs = nrow(changed_pairs),
            change_percent = if (nrow(valid_pairs)) {
              round(100 * nrow(changed_pairs) / nrow(valid_pairs), 1)
            } else {
              0
            },
            missing_pairs = nrow(consecutive_pairs) - nrow(valid_pairs),
            top_change = top_change
          )
        }
      }

      total_samples <- nrow(sample_counts)
      repeated_samples <- sum(sample_counts$TimesTested > 1)

      list(
        table = distribution %>%
          transmute(
            `Times Tested` = TimesTested,
            `Number of Samples` = NumberOfSamples,
            `Percent of Samples` = Percent
          ),
        total_samples = total_samples,
        total_instances = nrow(sample_runs),
        repeated_samples = repeated_samples,
        retest_rate = if (total_samples > 0) {
          repeated_samples / total_samples
        } else {
          NA_real_
        },
        transitions = transition_info
      )
    })

    output$sample_repeat_table <- renderTable({
      summary <- sample_repeat_summary()

      if (is.null(summary)) {
        return(tibble(`Times Tested` = integer(), `Number of Samples` = integer(), `Percent of Samples` = character()))
      }

      if (!is.null(summary$message)) {
        return(tibble(Message = summary$message))
      }

      table_data <- summary$table

      if (is.null(table_data)) {
        return(tibble(`Times Tested` = integer(), `Number of Samples` = integer(), `Percent of Samples` = character()))
      }

      table_data
    },
    striped = TRUE,
    bordered = TRUE,
    hover = TRUE,
    spacing = "s",
    align = "c",
    rownames = FALSE)

    output$sample_repeat_caption <- renderText({
      summary <- sample_repeat_summary()

      if (is.null(summary)) {
        return("No sample data available for the current filters.")
      }

      if (!is.null(summary$message)) {
        return(summary$message)
      }

      total_samples <- summary$total_samples
      total_instances <- summary$total_instances
      repeated <- summary$repeated_samples
      rate <- summary$retest_rate

      paste0(
        format(total_samples, big.mark = ","),
        " unique samples covering ",
        format(total_instances, big.mark = ","),
        " run-sample combinations. ",
        format(repeated, big.mark = ","),
        if (repeated == 1) " sample was" else " samples were",
        " tested more than once.",
        if (!is.na(rate)) {
          paste0(
            " Retest rate: ",
            scales::percent(rate, accuracy = 0.1),
            " (",
            format(repeated, big.mark = ","),
            " of ",
            format(summary$total_samples, big.mark = ","),
            ")."
          )
        } else {
          ""
        }
      )
    })

    output$sample_transition_table <- renderTable({
      summary <- sample_repeat_summary()

      if (is.null(summary)) {
        return(tibble(`Primary Call` = character(), `Secondary Call` = character(), `Number of Samples` = integer(), `Percent of Retests` = character()))
      }

      if (!is.null(summary$message)) {
        return(tibble(Message = summary$message))
      }

      transitions <- summary$transitions

      if (is.null(transitions) || !nrow(transitions$table)) {
        return(tibble(Message = "No paired primary/secondary results available."))
      }

      transitions$table
    },
    striped = TRUE,
    bordered = TRUE,
    hover = TRUE,
    spacing = "s",
    align = "c",
    rownames = FALSE)

      output$sample_transition_caption <- renderText({
        summary <- sample_repeat_summary()

      if (is.null(summary)) {
        return("No sample data available for the current filters.")
      }

      if (!is.null(summary$message)) {
        return(summary$message)
      }

      transitions <- summary$transitions

      if (is.null(transitions) || transitions$total_retests == 0) {
        return("No samples required both a primary and secondary MIC run within the filtered data.")
      }

      total_comparisons <- transitions$total_pairs + transitions$missing_pairs

      focus_suffix <- if (isTRUE(input$show_latest_followup)) " (showing only latest follow-up)" else ""

      base_text <- paste0(
        format(transitions$total_retests, big.mark = ","),
        " samples had multiple tests, contributing ",
        format(total_comparisons, big.mark = ","),
        if (total_comparisons == 1) " consecutive pair" else " consecutive pairs",
        focus_suffix,
        "."
      )

      if (transitions$total_pairs == 0) {
        return(paste(base_text, "However, Final Call information was missing for comparison."))
      }

      change_text <- paste0(
        format(transitions$changed_pairs, big.mark = ","),
        " (",
        scales::percent(transitions$changed_pairs / transitions$total_pairs, accuracy = 0.1),
        ") changed their Final Call between sequential runs."
      )

      top_change_text <- NULL
      if (!is.null(transitions$top_change)) {
        tc <- transitions$top_change
        top_change_text <- paste0(
          " Most common change: ",
          tc$primary,
          " → ",
          tc$secondary,
          " (",
          format(tc$samples, big.mark = ","),
          " samples)."
        )
      }

        paste0(base_text, " ", change_text, if (!is.null(top_change_text)) top_change_text else "")
      })

      output$sample_transition_sankey <- renderPlotly({
        summary <- sample_repeat_summary()

        if (is.null(summary)) {
          return(NULL)
        }

        if (!is.null(summary$message)) {
          return(
            plotly_empty(type = "sankey") %>%
              layout(
                annotations = list(
                  text = summary$message,
                  showarrow = FALSE,
                  x = 0.5,
                  y = 0.5,
                  xref = "paper",
                  yref = "paper"
                )
              )
          )
        }

        transitions <- summary$transitions

        if (is.null(transitions) || is.null(transitions$raw) || !nrow(transitions$raw)) {
          return(NULL)
        }

        raw <- transitions$raw

        labels <- sort(unique(c(raw$`Primary Call`, raw$`Secondary Call`)))
        label_lookup <- setNames(seq_along(labels) - 1, labels)

        sankey_data <- raw %>%
          mutate(
            source = label_lookup[`Primary Call`],
            target = label_lookup[`Secondary Call`],
            value = Samples
          )

        plot_ly(
          type = "sankey",
          arrangement = "snap",
          node = list(
            label = labels,
            pad = 15,
            thickness = 18,
            color = "#4F46E5"
          ),
          link = list(
            source = sankey_data$source,
            target = sankey_data$target,
            value = sankey_data$value,
            color = "rgba(79, 70, 229, 0.4)"
          )
        ) %>%
          layout(margin = list(t = 10, b = 10, l = 10, r = 10))
      })

      # === NEW: Replicate Concordance Heatmap ===
      output$heatmap_replicates <- renderPlotly({
      replicates <- if (is.null(filtered_replicates)) tibble() else filtered_replicates()

      if (!nrow(replicates)) {
        return(plotly_empty() %>% layout(title = "No replicate data available"))
      }

      target_map <- c(
        "177T" = "177T",
        "18S2" = "18S2",
        "RNAseP_DNA" = "RNAseP-DNA",
        "RNAseP_RNA" = "RNAseP-RNA"
      )

      summary_df <- replicates %>%
        filter(ControlType == "Sample", Target %in% names(target_map)) %>%
        mutate(TargetLabel = target_map[Target]) %>%
        group_by(SampleName, TargetLabel) %>%
        summarise(
          TotalReps = sum(!is.na(Cq)),
          PositiveReps = sum(Call == "Positive", na.rm = TRUE),
          .groups = "drop"
        ) %>%
        filter(TotalReps > 0)

      if (!nrow(summary_df)) {
        return(plotly_empty() %>% layout(title = "No replicate data available"))
      }

      sample_levels <- summary_df %>%
        group_by(SampleName) %>%
        summarise(
          TotalPositive = sum(PositiveReps, na.rm = TRUE),
          TotalReps = sum(TotalReps, na.rm = TRUE),
          .groups = "drop"
        ) %>%
        arrange(desc(TotalPositive), desc(TotalReps), SampleName) %>%
        slice_head(n = 50) %>%
        pull(SampleName)

      if (!length(sample_levels)) {
        return(plotly_empty() %>% layout(title = "No replicate data available"))
      }

      target_levels <- unname(target_map[c("177T", "18S2", "RNAseP_DNA", "RNAseP_RNA")])

      prop_mat <- matrix(NA_real_,
                         nrow = length(target_levels),
                         ncol = length(sample_levels),
                         dimnames = list(target_levels, sample_levels))

      text_mat <- matrix("",
                         nrow = length(target_levels),
                         ncol = length(sample_levels),
                         dimnames = list(target_levels, sample_levels))

      summary_filtered <- summary_df %>%
        filter(SampleName %in% sample_levels) %>%
        mutate(
          SampleName = factor(SampleName, levels = sample_levels),
          TargetLabel = factor(TargetLabel, levels = target_levels)
        ) %>%
        arrange(TargetLabel, SampleName)

      if (nrow(summary_filtered)) {
        for (i in seq_len(nrow(summary_filtered))) {
          row <- summary_filtered[i, ]
          target <- as.character(row$TargetLabel)
          sample <- as.character(row$SampleName)
          pos <- row$PositiveReps
          total <- row$TotalReps

          if (is.na(pos)) pos <- 0

          if (!is.na(total) && total > 0) {
            prop <- pos / total
            prop_mat[target, sample] <- prop
            percent_lbl <- paste0(round(prop * 100), "%")
            text_mat[target, sample] <- paste0(
              "Sample: ", sample, "<br>",
              "Target: ", target, "<br>",
              "Positive replicates: ", pos, "/", total, "<br>",
              "Percent positive: ", percent_lbl
            )
          } else {
            text_mat[target, sample] <- paste0(
              "Sample: ", sample, "<br>",
              "Target: ", target, "<br>",
              "No valid replicates"
            )
          }
        }
      }

      for (target in target_levels) {
        for (sample in sample_levels) {
          if (text_mat[target, sample] == "") {
            text_mat[target, sample] <- paste0(
              "Sample: ", sample, "<br>",
              "Target: ", target, "<br>",
              "No replicate data"
            )
          }
        }
      }

      plot_ly(
        x = sample_levels,
        y = target_levels,
        z = prop_mat,
        type = "heatmap",
        colorscale = list(c(0, "#f5f7fa"), c(1, "#27ae60")),
        zmin = 0,
        zmax = 1,
        text = text_mat,
        hoverinfo = "text",
        colorbar = list(title = "Proportion<br>Positive", tickformat = ".0%")
      ) %>%
        layout(
          title = paste0("Top ", length(sample_levels), " samples - ", length(target_levels), " markers"),
          xaxis = list(title = "Sample", tickangle = -45),
          yaxis = list(title = "Marker")
        )
    })

    # === NEW: Replicate Count Bar Chart ===
    output$bar_replicate_counts <- renderPlotly({
      replicates <- if (is.null(filtered_replicates)) tibble() else filtered_replicates()

      if (!nrow(replicates)) {
        return(plotly_empty() %>% layout(title = "No replicate data available"))
      }

      # Map target names
      target_map <- c(
        "177T" = "177T",
        "18S2" = "18S2",
        "RNAseP_DNA" = "RNAseP-DNA",
        "RNAseP_RNA" = "RNAseP-RNA"
      )

      # Calculate replicate counts for all targets
      rep_counts <- replicates %>%
        filter(ControlType == "Sample", Target %in% names(target_map), !is.na(Cq)) %>%
        mutate(TargetLabel = target_map[Target]) %>%
        group_by(SampleName, TargetLabel) %>%
        summarise(
          TotalReps = sum(!is.na(Cq)),
          PositiveReps = sum(Call == "Positive", na.rm = TRUE),
          .groups = "drop"
        )

      if (!nrow(rep_counts)) {
        return(plotly_empty() %>% layout(title = "No replicate data available"))
      }

      # Determine max replicates across all samples and targets
      max_reps <- max(rep_counts$PositiveReps, na.rm = TRUE)
      if (!is.finite(max_reps)) {
        max_reps <- 4
      }
      max_reps <- max(0, as.integer(ceiling(max_reps)))

      # Create distribution for each target
      fig <- plot_ly()

      targets <- c("177T", "18S2", "RNAseP-DNA", "RNAseP-RNA")
      target_colors <- c(
        "177T" = "#3498db",
        "18S2" = "#9b59b6",
        "RNAseP-DNA" = "#27ae60",
        "RNAseP-RNA" = "#e74c3c"
      )

      for (i in seq_along(targets)) {
        target <- targets[i]
        target_data <- rep_counts %>% filter(TargetLabel == target)

        if (nrow(target_data) > 0) {
          rep_distribution <- target_data %>%
            count(PositiveReps, name = "SampleCount") %>%
            tidyr::complete(PositiveReps = 0:max_reps, fill = list(SampleCount = 0)) %>%
            arrange(PositiveReps)

          fig <- fig %>%
            add_trace(
              data = rep_distribution,
              x = ~PositiveReps,
              y = ~SampleCount,
              type = "bar",
              name = target,
              marker = list(color = target_colors[[target]]),
              text = ~SampleCount,
              textposition = "outside",
              hovertemplate = paste0(
                "<b>", target, "</b><br>",
                "Positive Replicates: %{x}<br>",
                "Sample Count: %{y}<br>",
                "<extra></extra>"
              )
            )
        }
      }

      fig %>%
        layout(
          title = paste0("Positive Replicate Distribution - All Markers (n = ", length(unique(rep_counts$SampleName)), " samples)"),
          xaxis = list(title = "Number of Positive Replicates"),
          yaxis = list(title = "Sample Count"),
          barmode = "group",
          legend = list(title = list(text = "Marker"))
        )
    })

    # === NEW: Violin Plot - RNA Quality by Detection ===
    output$violin_quality <- renderPlotly({
      df <- filtered_base() %>%
        filter(ControlType == "Sample", !is.na(Delta_RP), !is.na(FinalCall))

      if (!nrow(df)) {
        return(plotly_empty() %>% layout(title = "No data available"))
      }

      df_plot <- df %>%
        mutate(Detection = case_when(
          grepl("Positive", FinalCall) ~ "Positive",
          FinalCall == "Negative" ~ "Negative",
          TRUE ~ "Other"
        )) %>%
        filter(Detection %in% c("Positive", "Negative"))

      plot_ly(df_plot, x = ~Detection, y = ~Delta_RP,
              split = ~Detection,
              type = 'violin',
              box = list(visible = TRUE),
              meanline = list(visible = TRUE),
              colors = c("Positive" = "#27ae60", "Negative" = "#95a5a6")) %>%
        layout(
          title = paste0("n = ", nrow(df_plot)),
          xaxis = list(title = "Detection Status"),
          yaxis = list(title = "ΔCq RNA Preservation"),
          showlegend = FALSE,
          shapes = list(
            list(type = "line", x0 = -0.5, x1 = 1.5, y0 = 5, y1 = 5,
                 line = list(color = 'green', dash = 'dash')),
            list(type = "line", x0 = -0.5, x1 = 1.5, y0 = 8, y1 = 8,
                 line = list(color = 'orange', dash = 'dash'))
          )
        )
    })

    # === NEW: QC Pass Rates ===
    output$bar_qc_rates <- renderPlotly({
      df <- filtered_base() %>%
        filter(ControlType == "Sample", !is.na(FinalCall))

      if (!nrow(df)) {
        return(plotly_empty() %>% layout(title = "No data available"))
      }

      df_qc <- df %>%
        mutate(
          QC_Status = case_when(
            is.na(Delta_RP) ~ "Unknown",
            Delta_RP <= 5 ~ "Good",
            Delta_RP <= 8 ~ "Moderate",
            TRUE ~ "Poor"
          ),
          CallSimplified = case_when(
            grepl("Positive", FinalCall) ~ "Positive",
            FinalCall == "Negative" ~ "Negative",
            TRUE ~ "Other"
          )
        ) %>%
        count(CallSimplified, QC_Status) %>%
        group_by(CallSimplified) %>%
        mutate(pct = n / sum(n) * 100)

      plot_ly(df_qc, x = ~CallSimplified, y = ~pct, color = ~QC_Status,
              type = "bar",
              colors = c("Good" = "#27ae60", "Moderate" = "#f39c12",
                        "Poor" = "#e74c3c", "Unknown" = "#95a5a6"),
              text = ~paste0(round(pct, 1), "%"),
              textposition = "inside") %>%
        layout(
          title = paste0("n = ", sum(df_qc$n)),
          xaxis = list(title = "Final Call"),
          yaxis = list(title = "Percentage"),
          barmode = "stack",
          legend = list(title = list(text = "RNA Quality"))
        )
    })

    # === NEW: Clinical Decision Matrix ===
    output$heatmap_decision_matrix <- renderPlotly({
      df <- filtered_base() %>%
        filter(ControlType == "Sample", !is.na(FinalCall))

      if (!nrow(df)) {
        return(plotly_empty() %>% layout(title = "No data available"))
      }

      df_matrix <- df %>%
        mutate(
          Pattern = case_when(
            Call_177T == "Positive" & Call_18S2 == "Positive" ~ "Both+",
            Call_177T == "Positive" & Call_18S2 != "Positive" ~ "DNA only",
            Call_177T != "Positive" & Call_18S2 == "Positive" ~ "RNA only",
            TRUE ~ "Both-"
          ),
          CallSimplified = case_when(
            grepl("Positive", FinalCall) ~ FinalCall,
            TRUE ~ FinalCall
          )
        ) %>%
        count(Pattern, CallSimplified) %>%
        tidyr::pivot_wider(names_from = CallSimplified, values_from = n, values_fill = 0)

      mat <- as.matrix(df_matrix[, -1])
      rownames(mat) <- df_matrix$Pattern

      plot_ly(z = mat,
              x = colnames(mat),
              y = rownames(mat),
              type = "heatmap",
              colorscale = "Greens",
              text = mat,
              texttemplate = "%{text}",
              hovertemplate = paste0(
                "Pattern: %{y}<br>",
                "Call: %{x}<br>",
                "Count: %{z}<br>",
                "<extra></extra>"
              )) %>%
        layout(
          title = paste0("n = ", sum(mat)),
          xaxis = list(title = "Final Call", tickangle = -45),
          yaxis = list(title = "Detection Pattern")
        )
    })

    # === NEW: Temporal Trends ===
    output$line_temporal <- renderPlotly({
      df <- filtered_base() %>%
        filter(ControlType == "Sample")

      if (!nrow(df)) {
        return(plotly_empty() %>% layout(title = "No temporal data available"))
      }

      plot_dates <- NULL

      if ("SampleDate" %in% names(df)) {
        plot_dates <- suppressWarnings(as.Date(df$SampleDate))
      } else if ("Date" %in% names(df)) {
        plot_dates <- suppressWarnings(as.Date(df$Date))
      } else if ("RunDate" %in% names(df)) {
        plot_dates <- suppressWarnings(as.Date(df$RunDate))
      }

      if (is.null(plot_dates)) {
        return(plotly_empty() %>% layout(title = "No temporal data available"))
      }

      df_temporal <- df %>%
        mutate(PlotDate = plot_dates) %>%
        filter(!is.na(PlotDate)) %>%
        mutate(Week = lubridate::floor_date(PlotDate, "week")) %>%
        group_by(Week) %>%
        summarise(
          Volume = n(),
          Positives = sum(grepl("Positive", FinalCall), na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(PositivityRate = Positives / Volume * 100)

      if (!nrow(df_temporal)) {
        return(plotly_empty() %>% layout(title = "No temporal data"))
      }

      # Create dual-axis plot
      fig <- plot_ly(df_temporal, x = ~Week)

      fig <- fig %>%
        add_bars(y = ~Volume, name = "Sample Volume",
                marker = list(color = '#3498db'), yaxis = "y1")

      fig <- fig %>%
        add_lines(y = ~PositivityRate, name = "Positivity %",
                 line = list(color = '#e74c3c', width = 3), yaxis = "y2")

      fig <- fig %>%
        layout(
          title = paste0("n = ", sum(df_temporal$Volume), " samples"),
          xaxis = list(title = "Week"),
          yaxis = list(title = "Sample Volume", side = "left"),
          yaxis2 = list(title = "Positivity Rate (%)",
                       overlaying = "y", side = "right"),
          legend = list(x = 0.1, y = 0.9)
        )

      fig
    })

    # === Geographic - Positivity by Structure Sanitaire ===
    output$bar_geo_positivity <- renderPlotly({
      df <- filtered_base() %>%
        filter(ControlType == "Sample")

      if (!nrow(df)) {
        return(plotly_empty() %>% layout(title = "No data available"))
      }

      # Try to find Structure Sanitaire column (various possible names)
      geo_col <- NULL
      possible_cols <- c("StructureSanitaire", "Structure_Sanitaire", "structure_sanitaire",
                         "HealthFacility", "Health_Facility", "Fosa", "FOSA",
                         "HealthZone", "Health_Zone", "ZoneSante", "Zone_Sante")

      for (col in possible_cols) {
        if (col %in% names(df)) {
          geo_col <- col
          break
        }
      }

      # Fallback to Province if no structure sanitaire found
      if (is.null(geo_col)) {
        if ("Province" %in% names(df)) {
          geo_col <- "Province"
        } else {
          return(plotly_empty() %>% layout(title = "No geographic data available"))
        }
      }

      df_geo <- df %>%
        filter(!is.na(.data[[geo_col]]), !is.na(FinalCall)) %>%
        mutate(
          GeoUnit = .data[[geo_col]],
          CallSimplified = case_when(
            FinalCall == "Positive" ~ "Positive (Both)",
            FinalCall == "Positive_DNA" ~ "DNA Only",
            FinalCall == "Positive_RNA" ~ "RNA Only",
            FinalCall == "LatePositive" ~ "Late Positive",
            FinalCall == "Negative" ~ "Negative",
            TRUE ~ "Other"
          )
        ) %>%
        count(GeoUnit, CallSimplified) %>%
        group_by(GeoUnit) %>%
        mutate(
          total = sum(n),
          pct = n / total * 100
        ) %>%
        ungroup()

      if (!nrow(df_geo)) {
        return(plotly_empty() %>% layout(title = "No geographic data"))
      }

      # Order by total samples (most to least)
      geo_order <- df_geo %>%
        group_by(GeoUnit) %>%
        summarise(total = sum(n), .groups = "drop") %>%
        arrange(desc(total)) %>%
        pull(GeoUnit)

      df_geo <- df_geo %>%
        mutate(GeoUnit = factor(GeoUnit, levels = geo_order))

      # Calculate positivity rate per unit for annotation
      positivity_by_unit <- df_geo %>%
        group_by(GeoUnit) %>%
        summarise(
          total = sum(n),
          positive = sum(n[CallSimplified %in% c("Positive (Both)", "DNA Only", "RNA Only", "Late Positive")]),
          rate = round(100 * positive / total, 1),
          .groups = "drop"
        )

      plot_ly(df_geo, x = ~GeoUnit, y = ~n, color = ~CallSimplified,
              type = "bar",
              colors = c(
                "Positive (Both)" = "#2ecc71",
                "DNA Only" = "#3498db",
                "RNA Only" = "#9b59b6",
                "Late Positive" = "#f39c12",
                "Negative" = "#95a5a6",
                "Other" = "#e67e22"
              ),
              text = ~paste0(n),
              textposition = "inside",
              hovertemplate = paste0(
                "<b>%{x}</b><br>",
                "%{fullData.name}: %{y}<br>",
                "<extra></extra>"
              )) %>%
        layout(
          title = list(
            text = paste0("Positivity by ", gsub("_", " ", geo_col), " (n = ", sum(df_geo$n), " samples)"),
            font = list(size = 14)
          ),
          xaxis = list(
            title = "",
            tickangle = -45,
            categoryorder = "array",
            categoryarray = geo_order
          ),
          yaxis = list(title = "Sample Count"),
          barmode = "stack",
          legend = list(
            title = list(text = "Final Call"),
            orientation = "h",
            y = -0.25
          ),
          margin = list(b = 120)
        )
    })

    # === Geographic - RNA Quality by Structure Sanitaire ===
    output$box_geo_quality <- renderPlotly({
      df <- filtered_base() %>%
        filter(ControlType == "Sample", !is.na(Delta_RP))

      if (!nrow(df)) {
        return(plotly_empty() %>% layout(title = "No data available"))
      }

      # Try to find Structure Sanitaire column (various possible names)
      geo_col <- NULL
      possible_cols <- c("StructureSanitaire", "Structure_Sanitaire", "structure_sanitaire",
                         "HealthFacility", "Health_Facility", "Fosa", "FOSA",
                         "HealthZone", "Health_Zone", "ZoneSante", "Zone_Sante")

      for (col in possible_cols) {
        if (col %in% names(df)) {
          geo_col <- col
          break
        }
      }

      # Fallback to Province if no structure sanitaire found
      if (is.null(geo_col)) {
        if ("Province" %in% names(df)) {
          geo_col <- "Province"
        } else {
          return(plotly_empty() %>% layout(title = "No geographic data available"))
        }
      }

      df_geo <- df %>%
        filter(!is.na(.data[[geo_col]])) %>%
        mutate(GeoUnit = .data[[geo_col]])

      if (!nrow(df_geo)) {
        return(plotly_empty() %>% layout(title = "No geographic quality data"))
      }

      # Order by median Delta_RP (best to worst)
      geo_order <- df_geo %>%
        group_by(GeoUnit) %>%
        summarise(median_delta = median(Delta_RP, na.rm = TRUE), .groups = "drop") %>%
        arrange(median_delta) %>%
        pull(GeoUnit)

      df_geo <- df_geo %>%
        mutate(GeoUnit = factor(GeoUnit, levels = geo_order))

      # Calculate summary stats for each unit
      summary_stats <- df_geo %>%
        group_by(GeoUnit) %>%
        summarise(
          n = n(),
          median_val = median(Delta_RP, na.rm = TRUE),
          good_pct = round(100 * sum(Delta_RP <= 5, na.rm = TRUE) / n(), 1),
          .groups = "drop"
        )

      # Color boxes by median quality
      df_geo <- df_geo %>%
        left_join(summary_stats %>% select(GeoUnit, median_val), by = "GeoUnit") %>%
        mutate(
          QualityCategory = case_when(
            median_val <= 5 ~ "Good",
            median_val <= 8 ~ "Moderate",
            TRUE ~ "Poor"
          )
        )

      plot_ly(df_geo, x = ~GeoUnit, y = ~Delta_RP,
              type = "box",
              color = ~QualityCategory,
              colors = c("Good" = "#27ae60", "Moderate" = "#f39c12", "Poor" = "#e74c3c"),
              hoverinfo = "y+name") %>%
        layout(
          title = list(
            text = paste0("RNA Preservation by ", gsub("_", " ", geo_col), " (n = ", nrow(df_geo), ")"),
            font = list(size = 14)
          ),
          xaxis = list(
            title = "",
            tickangle = -45,
            categoryorder = "array",
            categoryarray = geo_order
          ),
          yaxis = list(title = "ΔCq RNA Preservation (lower is better)"),
          showlegend = TRUE,
          legend = list(
            title = list(text = "Quality"),
            orientation = "h",
            y = -0.25
          ),
          margin = list(b = 120),
          shapes = list(
            list(type = "line", x0 = -0.5, x1 = length(geo_order) - 0.5, y0 = 5, y1 = 5,
                 line = list(color = '#27ae60', dash = 'dash', width = 2)),
            list(type = "line", x0 = -0.5, x1 = length(geo_order) - 0.5, y0 = 8, y1 = 8,
                 line = list(color = '#e74c3c', dash = 'dash', width = 2))
          ),
          annotations = list(
            list(x = 1.02, y = 5, xref = "paper", text = "Good (≤5)",
                 showarrow = FALSE, font = list(color = "#27ae60", size = 10)),
            list(x = 1.02, y = 8, xref = "paper", text = "Poor (>8)",
                 showarrow = FALSE, font = list(color = "#e74c3c", size = 10))
          )
        )
    })

  })
}
